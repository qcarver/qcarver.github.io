<!doctype html>
<head>
    <title></title>
    <style>
        body { margin: 0; 
               font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", "Roboto Light", "Segoe UI Web Light", "Segoe UI Light", "Segoe UI Web Regular", "Segoe UI", Helvetica, Arial, sans-serif; 
               margin: 1em;
               background: #293950;
               color: #ecf0f0;
        }
        svg {
            position: absolute;
            top: 0;
            left: 0;
        }
        rect { fill: transparent; }
        p.score {
            font-weight: normal;
            font-size: 2.4em;
            text-align: center;   
        }

        misses {
            color: red;
        }
        hits {
            color: green;
        }
    </style>
</head>
<body>
    <p id="score" class="score">Score: </p>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.4.11/d3.min.js"></script>
    <script src="d3moji.js"></script>  
    <script>
        var width = window.innerWidth,
                height = window.innerHeight,
                vOffset = 0,
                setupTime = 250,
                layoutSize = (Math.min(width, height)) / 3,
                minRadius = layoutSize / 6,
                maxRadius = minRadius * 6,
                emojiSize = minRadius * .75,
                transitTime = 30000;

//                var width = window.innerWidth,
//                height = window.innerHeight,
//                maxRadius = 60,
//                vOffset = 0,
//                setupTime = 250,
//                layoutSize = (Math.min(width, height)) / 3,
//                minRadius = layoutSize / 8,
//                emojiSize = minRadius,
//                transitTime = 30000;

        var evalFunction = function () {
            return false;
        };

        // D3 Bubble Chart 

//        var canvas = d3.select('body').append('canvas')
//                .attr('width', width)
//                .attr('height', height)
//                .node().getContext('2d');

        var art = d3.select('body').append('svg')
                .attr('width', width)
                .attr('height', height)
                .append('g');

        art.append('rect')
                .attr('class', 'overlay')
                .attr('width', width)
                .attr('height', height);

        var chart = d3.select('body').append('svg')
                .attr('width', width)
                .attr('height', height)
                .append('g');

        chart.append('rect')
                .attr('class', 'overlay')
                .attr('width', width)
                .attr('height', height);

        var g = art.append("g");


        function drawCluster(m) {
            var object = JSON.parse(m);
            var jsonData = processData(m);
            layoutSize = 10;
            jsonData.children.forEach(function (o) {
                if ((o.size * 2) > layoutSize) {
                    //roughly the radius of the cluster
                    layoutSize += o.size;
                }
            });
            setVOffset();
            var cluster = d3.layout.pack()
                    .size([layoutSize, layoutSize])
                    //.radius(200)
                    .value(function (d) {
                        return d.size;
                    }) // new data is loaded to bubble layout
                    .radius(this.value)
                    .padding(3);
            //console.log("bubble chart layout packed with size" + layoutSize);
            // generate data with calculated layout values
            var nodes = cluster.nodes(jsonData)
                    .filter(function (d) {
                        if (!d.children) {
                            return true;
                        }
                    }); // filter out the root object

            //DATA JOIN: assign new data to existing DOM 
            var vis = chart.selectAll("g")
                    .data(nodes, function (d) {
                        return d.uid;
                    });

            //UPDATE: //there is no UPDATE in this design

//ENTER + UPDATE
            vis.enter()
                    .append("g")
                    //.size(500,500)
                    .attr('transform', function (d) {
                        return 'translate(' + (d.x - width / 10) + ',' + (d.y + vOffset) + ')';
                    })
                    .transition("enter")
                    .duration(transitTime / 2)
                    .attr('transform', function (d) {
                        return 'translate(' + (d.x + (width * 1.1)) + ',' + (d.y + vOffset) + ')';
                    })
                    .ease('linear')
                    .transition("remove")
                    .duration(0)
                    .remove()
                    ;


            // enter - only applies to incoming elements (once emptying data)	
            vis.append('circle')
                    .attr('r', function (d) {
                        return d.r; //the radius circle pack thinks this should be
                    })
                    .attr('class', function (d) {
                        return d.className;
                    })
                    .attr("id", function (d) {
                        return "circle-" + d.uid;
                    });


            vis.append('emoji')
                    .attr('symbol', function (d) {
                        return emojiHash(d.name);
                    })
                    .attr('width', function (d) {
                        return emojiSize; //d.r * 1.5;
                    })
                    .attr('height', function (d) {
                        return emojiSize; //d.r * 1.5;
                    })
                    .attr('opacity', 255)
                    .attr("transform", function (d) {
                        //return "translate(" + (-.75 * d.r) + "," + (-.75 * d.r) + ")";
                        return "translate(" + (-.5 * emojiSize) + "," + (-.5 * emojiSize) + ")";
                    });

//            //draw rings for number size
            chart.selectAll("g").filter(function (d) {
                return isNaN(d.contents);
            }).append("text")
                    .attr("dx", function (d) {
                        return -20;
                    })
                    .text(function (d) {
                        return d.contents;
                    });

            chart.selectAll("g").filter(function (d) {
                return !isNaN(d.contents);
            }).each(function (d) {
                //draw rings for number size
                console.log("###d.r is :" + d.r + " for field named: " + d.name);
                this_uid = d.uid;
                var sizeAsBinaryString = d.r.toString(2).split('.', 1)[0];
                for (var i = 0; i < sizeAsBinaryString.length; i++) {
                    if (sizeAsBinaryString[sizeAsBinaryString.length - i] === "1") {
                        chart.selectAll("g").filter(function (d) {
                            return d.uid === this_uid;
                        }).append('circle')
                                .attr('r', function (d) {
                                    return ((i * (d.r - emojiSize / 2) / sizeAsBinaryString.length) + (emojiSize / 2)); //the radius circle pack thinks this should be
                                })
                                .style("stroke-width", 1)    // set the stroke width
                                .style("stroke", "#293950")      // set the line colour ..hardcoded to bg color
                                .style("opacity", .4)
                                .style("fill", "none");
                    }
                }
            });

            //this is the clickable region, transparent and bigger than the object
            vis.append("circle")
                    .attr('r', function (d) {
                        return d.r + 60; // bigger than radius of visible objects
                    })
                    .style("fill", "white")
                    .style("opacity", 0).on('click', function (d) {
                processClick(evalFunction(object));
                chart.selectAll("g")
                        .data(nodes, function (d) {
                            return d.uid;
                        }).remove();
            });
        }

        var hits = 0;
        var misses = 0;

        function processClick(hit) {
            console.log("click!");
            if (hit === true) {
                g.append("svg:image")
                        //.attr("xlink:href", "http://www.clker.com/cliparts/1/4/5/a/1331068897296558865Sitting%20Racoon.svg")
                        .attr("xlink:href", "Green_check.svg")
                        .attr("id", "feedback-1")
                        .attr("width", height / 2)
                        .attr("height", height / 2)
                        .attr("x", width / 4)
                        .attr("y", height / 4);
                hits++;
            } else {
                g.append("svg:image")
                        .attr("xlink:href", "Red_x.svg")
                        .attr("id", "feedback-1")
                        .attr("width", height / 2)
                        .attr("height", height / 2)
                        .attr("x", width / 4)
                        .attr("y", height / 4);
                misses++;
            }
            setTimeout(function () {
                d3.select("#feedback-1").remove();
            }, 100);

            document.getElementById('score').innerHTML =
                    "Score: " +
                    "<m style='color:red;'>" + misses + ": </m>" +
                    "<h style='color:green;'>" + hits + "</h>";
        }

        function processData(data) {
            if (!data)
                return;
            var dataSet = [];
            var obj = JSON.parse(data);
            traverse(obj, dataSet, "root");
            return {children: dataSet};
        }

        function traverse(o, dataSet, parentName) {
            for (var i in o) {
                if (o[i] !== null) {
                    //skip over container objects 
                    if (typeof (o[i]) === "object")
                    {
                        //going one step down in the object tree!!
                        traverse(o[i], dataSet, i);
                    } else {
                        //represent false booleans simply by not showing them
                        if (o[i].toString().toUpperCase() !== "FALSE") {
                            //only push on fields (not objects)
                            var size = circleSize(o[i]);
                            var uid = Math.floor((1 + Math.random()) * 0x10000);
                            //layoutSize += size;
                            dataSet.push({name: i, className: getClassName(parentName), size: size
                                , uid: (uid), vOffset: vOffset, clicked: false, contents: o[i]});
                            console.log("uid: " + uid + "  " + parentName + "." + i + " : " + o[i] + " = " + size);
                        }
                    }
                }
            }
        }

        function getClassName(name) {
            if (document.getElementsByClassName(name).length === 0) {
                var style = document.createElement('style');
                style.type = 'text/css';
                style.innerHTML = '.' + name + ' { fill: #' + getHashColor(name) + '; background: #F495A3; }';
                document.getElementsByTagName('head')[0].appendChild(style);
            }
            return name;
        }


        function getHashColor(name) {
            var hash = 0, i, chr;
            if (name.length === 0)
                return hash;
            for (i = 0; i < name.length; i++) {
                chr = name.charCodeAt(i);
                //try and distribute the char a-z or A-Z to a # between 0&255
                chr = (chr < 97) ? chr - 64 : chr - 70;
                chr += (52 * (chr % 5)) + i % 5;
                //shift determines which of the 3 bytes we want to update
                var shift = (name.length > 2) ? (i % 3) : (chr % 3);
                //update the byte by adding to it
                hash += ((chr | (hash & 0xFF)) << 8 * shift);
            }
            //we used addition so.. number might exceed 3 bytes now, mask it
            hash &= 0xFFFFFF;
            //this gets our number to a six character hex representation of hash
            var pad = "000000";
            return pad.substring(0, pad.length - hash.toString(16).length) + hash.toString(16);
        }

        function circleSize(value) {
            var d = (isNaN(value) ? value.length : value);
            f = d3.scale.log().base(2).domain([Math.exp(0), Math.exp(7.5)]).range([minRadius, maxRadius])
//            d = Math.ceil(Math.min(maxRadius + Math.log10(d), Math.max(minRadius, d / 2)));
//            if (d < minRadius)
//                d = minRadius + d;
            return f(d);
        }

        //////////////////////other utilities    
        function setVOffset() {
            //Rnd vertical offset for new group that differs from last vOffset
            vOffset = (Math.random() * (height - layoutSize) + vOffset) % (height - layoutSize);
        }


        //hash any given string to an emoji name.. gets the icon from eg: https://twemoji.maxcdn.com/svg/1f4af.svg
        function emojiHash(hashMe) {
            return Object.keys(emojiMap)[Math.abs(hashMe.hashCode()) % Object.keys(emojiMap).length];
        }

        //add a function to the native String type to emulate java's hashCode()
        String.prototype.hashCode = function () {
            var hash = 0;
            if (this.length === 0)
                return hash;
            for (var i = 0; i < this.length; i++) {
                var character = this.charCodeAt(i);
                hash = ((hash << 5) - hash) + character;
                hash = hash & hash; // Convert to 32bit integer
            }
            return hash;
        };

        var request = new XMLHttpRequest();
        request.open("GET", "MOCK_DATA.json", false);
        request.send(null);
        var JSON_object = JSON.parse(request.responseText);
        evalFunction = new Function("obj", JSON_object.eval_function);
        var test_data = [];
        test_data = JSON_object.test_data;
        test_data.forEach(function (td, index) {
            setTimeout(function () {
                objAsString = JSON.stringify(td);
                drawCluster(objAsString);
                console.log("sending " + objAsString + " in " + index * (2000) + " ms");
            },
                    index * transitTime / 8);
        }
        );

    </script>
</body>
